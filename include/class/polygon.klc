PROGRAM class_name
%NOBUSYLAMP
%COMMENT = 'polygon object'
%NOLOCKGROUP
%UNINITVARS

--*** ..todo:: Does not work for polygons with holes

%include namespace.m

%include errors.klt
%include systemlib.klt
%include draw.klt

VAR
  this : PATH nodedata = t_VERTEX
  sub_poly : PATH nodedata = t_VERTEX
  hull : PATH nodedata = t_VERTEX
  lines : PATH nodedata = t_SEGMENT2D
  canvas : XYZWPR

  dummy_poly1 : PATH nodedata = t_VERTEX

%include errors.klh
%include draw.klh
%include polygon.klh
%include polygon.private.klh


-- ** private **

ROUTINE clear_hull
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    i = PATH_LEN(hull)
    WHILE PATH_LEN(hull) > 0 DO
		  DELETE_NODE(hull,i,status)
      CHK_STAT(status)
      i = i - 1
	  ENDWHILE
  END clear_hull

ROUTINE clear_poly
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    i = PATH_LEN(p)
    WHILE PATH_LEN(p) > 0 DO
		  DELETE_NODE(p,i,status)
      CHK_STAT(status)
      i = i - 1
	  ENDWHILE
  END clear_poly

ROUTINE clear_lines
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    i = PATH_LEN(lines)
    WHILE PATH_LEN(lines) > 0 DO
		  DELETE_NODE(lines,i,status)
      CHK_STAT(status)
      i = i - 1
	  ENDWHILE
  END clear_lines

ROUTINE new_sub_poly
  VAR
    nde_strt, nde_end : INTEGER
    i : INTEGER
    status : INTEGER
  BEGIN
    nde_strt = 1; nde_end = PATH_LEN(this);
    --find polygon
    IF (polygon > 0) THEN
      i = 1
      REPEAT
        nde_strt = i
        --handle uninitialized nextPoly
        IF this[i].nextPoly = DEFAULT_SHORT THEN
          nde_end = PATH_LEN(this)
        ELSE
          nde_end = this[i].nextPoly - 1
        ENDIF

        i = this[i].nextPoly
      UNTIL(this[i].polygon > polygon)
    ENDIF

    --clear to sub path
    clear_poly(sub_poly)
    COPY_PATH(this, nde_strt, nde_end, sub_poly, status)
    CHK_STAT(status)

  END new_sub_poly

ROUTINE update_last_poly
  VAR
    i : INTEGER
    polygon : INTEGER
  BEGIN
    --append pointer to next polygon if other
    --polygons exist
    i = PATH_LEN(this)
    IF i > 0 THEN
      -- ..danger:: polygon is a BYTE. Defaults to 255.
      IF this[i].polygon < DEFAULT_BYTE THEN
        polygon = this[i].polygon
      ELSE
        polygon = 1
      ENDIF
      -- ..danger:: nextPoly is SHORT defaults to 32767. change if changing type.
      WHILE (i > 0) OR (this[i].nextPoly = DEFAULT_SHORT) OR UNINIT(this[i].nextPoly) DO
        this[i].nextPoly = PATH_LEN(this) + 1
        i = i - 1
      ENDWHILE
    ELSE
      polygon = 1
    ENDIF

    RETURN(polygon)
  END update_last_poly

-- ** public **

ROUTINE clear
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    i = PATH_LEN(this)
    WHILE PATH_LEN(this) > 0 DO
		  DELETE_NODE(this,i,status)
      i = i - 1
	  ENDWHILE
    --uninitialize the canvas
    SET_UNINIT_F('class_name', 'canvas')

    --clear hull
    clear_hull
    --clear to sub path
    clear_poly(sub_poly)
    clear_poly(dummy_poly1)

    clear_lines
  END clear

ROUTINE set_canvas
  BEGIN
    canvas = frm
  END set_canvas

ROUTINE append_vertex
  VAR
    status : INTEGER
    nd : t_VERTEX
  BEGIN
    IF UNINIT(canvas) THEN
      karelError(VAR_UNINIT,'class_name member "canvas" needs to' + &
                ' be set before building polygons', ER_ABORT)
    ENDIF
    APPEND_NODE(this,status)
    CHK_STAT(status)
    nd.coords = VEC2D(vertex.x, vertex.y)
    nd.polygon = polygon
    this[PATH_LEN(this)] = nd
  END append_vertex

ROUTINE append_polygon
  VAR
    i : INTEGER
    polygon : INTEGER
  BEGIN
    polygon = update_last_poly

    FOR i=1 TO PATH_LEN(verticies) DO
      append_vertex(verticies[i].coords, (polygon))
    ENDFOR
  END append_polygon

ROUTINE append_polygon_array
  VAR
    i : INTEGER
    polygon : INTEGER
  BEGIN
    polygon = update_last_poly

    FOR i=1 TO ARRAY_LEN(verticies) DO
      append_vertex(verticies[i], (polygon))
    ENDFOR
  END append_polygon_array


ROUTINE get_lines
  VAR
    status : INTEGER
  BEGIN
    COPY_PATH(lines, start_i, end_i, out_lines, status)
    CHK_STAT(status)
  END get_lines

ROUTINE raster
  VAR
    i, status : INTEGER
  BEGIN
    --use full polygon if sub_poly is
    --not defined
    IF PATH_LEN(sub_poly) = 0 THEN
      new_sub_poly(0)
    ENDIF
    --clear previous lines
    clear_lines

    --get walls
    i = 0
    WHILE (i < wall_lines) DO
      --clear inset
      clear_poly(dummy_poly1)
      --inset by width of line to fill
      --within boundaries
      draw__inset_polygon(sub_poly, (line_width/2 + i*line_pitch), hull, dummy_poly1)
      --trace polygon
      draw__trace(dummy_poly1, 0, lines)
      i = i + 1
    ENDWHILE

    IF wall_lines = 0 THEN
      COPY_PATH(sub_poly, 1 , PATH_LEN(sub_poly), dummy_poly1, status)
    ENDIF

    --raster the interior
    draw__raster_lines(dummy_poly1, hull, raster_angle, line_width, line_pitch, lines)

  END raster

ROUTINE world_transform
  BEGIN
    draw__raster2d_to_raster(lines, canvas, out_lines)
  END world_transform


  BEGIN
  END class_name
