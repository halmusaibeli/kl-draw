PROGRAM draw
%NOBUSYLAMP
%COMMENT = '2d library'
%NOLOCKGROUP
%NOPAUSE = COMMAND + TPENABLE + ERROR

%include systemvars.klt
%include math.klt
%include draw.klt

%include systemlib.klh
%from math.klh %import norm, norm2, average_vector
%include draw.klh
%include draw.private.klh

ROUTINE VEC2D
  VAR
    v : VECTOR
  BEGIN
    v.x = x; v.y = y; v.z = 0;
    RETURN(v)
  END VEC2D

ROUTINE draw__vec_to_vec2d
  VAR
    v_trans : VECTOR
    v2 : VECTOR
  BEGIN
    --get vector relative to frame
    v_trans = INV((frame)):v
    --remove z componenet
    v2.x = v_trans.x ; v2.y = v_trans.y ; v2.z = 0 ;
    RETURN(v2)
  END draw__vec_to_vec2d
  
ROUTINE draw__vec2d_to_vec
  VAR
    v2 : VECTOR
  BEGIN
    v2.x = v.x ; v2.y = v.y ; v2.z = 0 ;
    v2 = frame:v2
    RETURN(v2)
  END draw__vec2d_to_vec

ROUTINE draw__vec2d_to_pos
  VAR
    v2 : VECTOR
    p : XYZWPR
  BEGIN
    v2.x = v.x ; v2.y = v.y ; v2.z = 0 ;
    v2 = frame:v2
    --add orientation
    p.w = frame.w; p.p = frame.p; p.r = frame.r;

    RETURN(p)
  END draw__vec2d_to_pos

ROUTINE draw__LINE_to_LINE2D
  VAR
    l2 : t_LINE2D
  BEGIN
    l2.point = draw__vec_to_vec2d(l.point, frame)
    l2.vec = draw__vec_to_vec2d(l.vec, frame)

    RETURN(l2)
  END draw__LINE_to_LINE2D

ROUTINE draw__LINE2D_to_LINE
  VAR
    l2 : t_LINE
  BEGIN
    l2.point = draw__vec2d_to_vec(l.point, frame)
    l2.vec = draw__vec2d_to_vec(l.vec, frame)

    RETURN(l2)
  END draw__LINE2D_to_LINE

ROUTINE draw__SEGMENT_to_SEGMENT2D
  VAR
    l2 : t_SEGMENT2D
  BEGIN
    l2.r0 = draw__vec_to_vec2d(l.r0, frame)
    l2.r1 = draw__vec_to_vec2d(l.r1, frame)

    RETURN(l2)
  END draw__SEGMENT_to_SEGMENT2D

ROUTINE draw__SEGMENT2D_to_SEGMENT
  VAR
    l2 : t_SEGMENT
  BEGIN
    l2.r0 = draw__vec2d_to_vec(l.r0, frame)
    l2.r1 = draw__vec2d_to_vec(l.r1, frame)

    RETURN(l2)
  END draw__SEGMENT2D_to_SEGMENT


ROUTINE draw__perpendicular_vector
  VAR
    v_out : VECTOR
  BEGIN
    v_out.x = -1*v.y
    v_out.y = v.x
    v_out.z = 0
    RETURN(v_out)
  END draw__perpendicular_vector

ROUTINE draw__angle_to_vector
  VAR
    v : VECTOR
  BEGIN
    v.x = COS(angle) ; v.y = SIN(angle) ; v.z = 0;
    RETURN(v)
  END draw__angle_to_vector

ROUTINE draw__vector_to_angle
  BEGIN
    RETURN(ATAN2(v.y, v.x) * 180/M_PI)
  END draw__vector_to_angle

ROUTINE draw__intersect
  VAR
    --line normals
    n_l1, n_l2 : VECTOR
    -- perpendicular line normals
    perp_l1, perp_l2 : VECTOR
    --Window Edge Coordinates
    --how far away a poitn is from a line
    -- +ive to left of line. -ive to right of line
    WEC1, WEC2 : ARRAY[2] OF REAL
  BEGIN
    --create vector normals, and perpendicular normals
    --for both lines
    n_l1 = (l1.r1 - l1.r0)/math__norm((l1.r1 - l1.r0))
    perp_l1 = draw__perpendicular_vector(n_l1)

    n_l2 = (l2.r1 - l2.r0)/math__norm((l2.r1 - l2.r0))
    perp_l2 = draw__perpendicular_vector(n_l2)

    --for each endpoint determine which side of the opposing line
    --it is on. Using a lines (Q1Q2) perpendicular vector (Q2-Q1)⊥, 
    --and the dot product between a point's (P) vector with the line (PQ1).
    --The product will be negative to the right of the line (In the negative
    --half space of the line), or positive to the left of the line (In the 
    --positive half space of the line).
    -- (ref: https://math.stackexchange.com/questions/2945417/unknown-mathematical-symbols)

    --using l2 line (P-Q1)*(Q2-Q1)⊥
    WEC1[1] = (l1.r0 - l2.r0)@perp_l2
    WEC1[2] = (l1.r1 - l2.r0)@perp_l2

    --using l1 line (P-Q1)*(Q2-Q1)⊥
    WEC2[1] = (l2.r0 - l1.r0)@perp_l1
    WEC2[2] = (l2.r1 - l1.r0)@perp_l1

    --if endpoints are on opposite sides of the line (one +ive, one -ive), 
    --the line intersects with the other one.
    IF (WEC1[1]*WEC1[2] > 0) AND (WEC2[1]*WEC2[2] > 0) THEN
      RETURN(FALSE)
    ELSE
      --ratios with WEC can be made to give a ratio for how for much of one
      --line lies to the left of another line. For clipping the line you
      --would want to remove the 1-alpha of the line if your polygon hull is
      --sequenced ccw.
      out_alpha1 = WEC1[1]/(WEC1[1]-WEC1[2])
      out_alpha2 = WEC2[1]/(WEC2[1]-WEC2[2])

      RETURN(TRUE)
    ENDIF

    RETURN(FALSE)
  END draw__intersect


-- private polygon routines

--comparator = TRUE : >, comparator = FALSE : <
ROUTINE glt(r1, r2 : REAL; comparator : BOOLEAN) : BOOLEAN
  BEGIN
    IF comparator THEN
      RETURN(r1 > r2)
    ELSE
      RETURN(r1 < r2)
    ENDIF
  END glt


--comparator = TRUE : >, comparator = FALSE : <
ROUTINE minmax(point_arr : ARRAY[*] OF VECTOR; search_vec : VECTOR; comparator : BOOLEAN) : INTEGER
  VAR
   i : INTEGER
   minmax_idx : INTEGER
   valy, valx : REAL
   origin : VECTOR
   perp_vec : VECTOR
  BEGIN
    origin = VEC2D(0,0)
    --get perpendicular vector
    perp_vec = draw__perpendicular_vector(search_vec)
    --find y min
    minmax_idx = 1
    --dot product between (point-origin) and search vector
    --will give the point with the maximum distance from the
    --origin wrt the search vector
    valy = (search_vec@(point_arr[1]-origin))
    FOR i=2 TO ARRAY_LEN(point_arr) DO
      --if uninit vector assume at end of list
      IF UNINIT(point_arr[i].x) THEN RETURN(minmax_idx) ; ENDIF

      IF (glt( (search_vec@(point_arr[i]-origin)), valy, comparator) ) THEN
        valy = (search_vec@(point_arr[i]-origin)) 
        minmax_idx = i

      ELSE IF ((search_vec@(point_arr[i]-origin)) = valy) THEN
        valx = (perp_vec@(point_arr[minmax_idx]-origin))
        IF (glt( (perp_vec@(point_arr[i]-origin)), valx,  NOT comparator) ) THEN
          valx = (perp_vec@(point_arr[minmax_idx]-origin))
          minmax_idx = i
        ENDIF
      ENDIF
      ENDIF
    ENDFOR

    RETURN(minmax_idx)

  END minmax

ROUTINE draw__find_min
  BEGIN
    RETURN( minmax(point_arr, search_vec, FALSE) )
  END draw__find_min

ROUTINE draw__find_max
  BEGIN
    RETURN( minmax(point_arr, search_vec, TRUE) )
  END draw__find_max

ROUTINE draw__on_hull
  VAR
    i : INTEGER
    b : BOOLEAN
  BEGIN
    b = FALSE
    FOR i=1 TO ARRAY_LEN(arr) DO
      IF NOT UNINIT(arr[i]) THEN
      IF (v = arr[i]) THEN
        b = TRUE
      ENDIF
      ENDIF
    ENDFOR

    RETURN(b)
  END draw__on_hull

-- public polygon routines
ROUTINE draw__convex_hull
-- (ref : https://www.geeksforgeeks.org/convex-hull-set-1-jarviss-algorithm-or-wrapping/)
-- (ref : https://www.topcoder.com/community/competitive-programming/tutorials/geometry-concepts-line-intersection-and-its-applications#convexhull)
  VAR
   i,j : INTEGER
   end_idx : INTEGER
   min_hull : INTEGER
   curr, nxt, tst : INTEGER
   dummy_v : VECTOR
   dot : REAL
   det, prev_det : REAL
  BEGIN
    -- set end index
    FOR i=1 TO ARRAY_LEN(verticies) DO
      IF NOT UNINIT(verticies[i]) THEN
        end_idx = i
      ENDIF
    ENDFOR

    --find y min
    min_hull = draw__find_min(verticies, VEC2D(0,1))
    
    --min point must be on hull
    curr = min_hull

    --skip first point as we know it is min_hull
    -- and will be the last found hull point
    j = 1

    REPEAT
      -- reset tentative hull point
      nxt = -1

      prev_det = 0

      FOR i=1 TO end_idx DO
        -- for next point (curr+i)%end_idx
        tst = ((curr+i-1) MOD end_idx) + 1

        -- cross product will determine the furthest point
        -- from the line nxt->curr.

        --Do not test if in hull set. But abort out 
        IF (tst <> curr) AND NOT draw__on_hull(verticies[tst], out_hull) THEN
          IF (nxt = -1) THEN
            nxt = ((curr+i-1) MOD end_idx) + 1
          ENDIF

          dummy_v = (verticies[curr]-verticies[nxt])#(verticies[tst]-verticies[nxt])
          det = dummy_v.z

          --det = 0, nxt and tst are colinear
          IF det = 0 THEN
            --points are on the same line select the one furthest
            --away
            dot = (verticies[curr]-verticies[nxt])@(verticies[tst]-verticies[nxt])
            -- if dot product is negative tst is further away
            IF dot < 0 THEN
              nxt = tst
            ENDIF
          ENDIF

          IF det > prev_det THEN
            nxt = tst
            prev_det = det
          ENDIF
        ENDIF
      ENDFOR
      -- add point furthest counter clockwise from current point to hull
      curr = nxt

      j = j + 1
      out_hull[j] = verticies[nxt]

    UNTIL(curr = min_hull)

    --swap last point into first point position as this is the
    --min_hull point
    out_hull[1] = out_hull[j]

  END draw__convex_hull

ROUTINE draw__bounding_box
  VAR
    edges : ARRAY[4] OF VECTOR
    box : t_RECT
    align_vec, perp_vec : VECTOR
    frm : XYZWPR
    i : INTEGER
  BEGIN
    --y-axis vector
    align_vec = draw__angle_to_vector(angle + 90)
    --x-axis vector
    perp_vec = draw__perpendicular_vector(align_vec)

    --find four corners
    edges[1] = verticies[draw__find_min(verticies, align_vec)]
    edges[2] = verticies[draw__find_max(verticies, perp_vec)]
    edges[3] = verticies[draw__find_max(verticies, align_vec)]
    edges[4] = verticies[draw__find_min(verticies, perp_vec)]

    --put edges in rotated frame
    frm.x = 0; frm.y = 0; frm.z = 0; frm.w = 0; frm.p = 0; frm.r = angle ;
    FOR i=1 TO ARRAY_LEN(edges) DO
      edges[i] = INV(frm):edges[i]
    ENDFOR

    box.verts[1] = frm:(VEC2D(edges[2].x, edges[1].y))
    box.verts[2] = frm:(VEC2D(edges[4].x, edges[1].y))
    box.verts[3] = frm:(VEC2D(edges[4].x, edges[3].y))
    box.verts[4] = frm:(VEC2D(edges[2].x, edges[3].y))

    box.vec = align_vec
    box.center = math__average_vector(box.verts)

    RETURN(box)

  END draw__bounding_box

BEGIN
END draw

