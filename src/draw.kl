PROGRAM draw
%NOBUSYLAMP
%COMMENT = '2d library'
%NOLOCKGROUP
%NOPAUSE = COMMAND + TPENABLE + ERROR

%include systemvars.klt
%include math.klt
%include draw.klt

%include systemlib.klh
%from errors.klh %import CHK_STAT
%from math.klh %import norm, norm2, average_vector, ceil
%include draw.klh
%include draw.private.klh

--use for sorted line intersections with polygon
%class srtclp('arraysort.klc','arraysort.klh','sortintrsct.klt')

ROUTINE VEC2D
  VAR
    v : VECTOR
  BEGIN
    v.x = x; v.y = y; v.z = 0;
    RETURN(v)
  END VEC2D

ROUTINE draw__vec_to_vec2d
  VAR
    v_trans : VECTOR
    v2 : VECTOR
  BEGIN
    --get vector relative to frame
    v_trans = INV((frame)):v
    --remove z componenet
    v2.x = v_trans.x ; v2.y = v_trans.y ; v2.z = 0 ;
    RETURN(v2)
  END draw__vec_to_vec2d
  
ROUTINE draw__vec2d_to_vec
  VAR
    v2 : VECTOR
  BEGIN
    v2.x = v.x ; v2.y = v.y ; v2.z = 0 ;
    v2 = frame:v2
    RETURN(v2)
  END draw__vec2d_to_vec

ROUTINE draw__vec2d_to_pos
  VAR
    v2 : VECTOR
    p : XYZWPR
  BEGIN
    v2.x = v.x ; v2.y = v.y ; v2.z = 0 ;
    v2 = frame:v2
    --add orientation
    p.w = frame.w; p.p = frame.p; p.r = frame.r;

    RETURN(p)
  END draw__vec2d_to_pos

ROUTINE draw__LINE_to_LINE2D
  VAR
    l2 : t_LINE2D
  BEGIN
    l2.point = draw__vec_to_vec2d(l.point, frame)
    l2.vec = draw__vec_to_vec2d(l.vec, frame)

    RETURN(l2)
  END draw__LINE_to_LINE2D

ROUTINE draw__LINE2D_to_LINE
  VAR
    l2 : t_LINE
  BEGIN
    l2.point = draw__vec2d_to_vec(l.point, frame)
    l2.vec = draw__vec2d_to_vec(l.vec, frame)

    RETURN(l2)
  END draw__LINE2D_to_LINE

ROUTINE draw__SEGMENT_to_SEGMENT2D
  VAR
    l2 : t_SEGMENT2D
  BEGIN
    l2.r0 = draw__vec_to_vec2d(l.r0, frame)
    l2.r1 = draw__vec_to_vec2d(l.r1, frame)

    RETURN(l2)
  END draw__SEGMENT_to_SEGMENT2D

ROUTINE draw__SEGMENT2D_to_SEGMENT
  VAR
    l2 : t_SEGMENT
  BEGIN
    l2.r0 = draw__vec2d_to_vec(l.r0, frame)
    l2.r1 = draw__vec2d_to_vec(l.r1, frame)

    RETURN(l2)
  END draw__SEGMENT2D_to_SEGMENT


ROUTINE draw__perpendicular_vector
  VAR
    v_out : VECTOR
  BEGIN
    v_out.x = -1*v.y
    v_out.y = v.x
    v_out.z = 0
    RETURN(v_out)
  END draw__perpendicular_vector

ROUTINE draw__angle_to_vector
  VAR
    v : VECTOR
  BEGIN
    v.x = COS(angle) ; v.y = SIN(angle) ; v.z = 0;
    RETURN(v)
  END draw__angle_to_vector

ROUTINE draw__vector_to_angle
  BEGIN
    RETURN(ATAN2(v.y, v.x) * 180/M_PI)
  END draw__vector_to_angle

ROUTINE draw__intersect
  VAR
    --line normals
    n_l1, n_l2 : VECTOR
    -- perpendicular line normals
    perp_l1, perp_l2 : VECTOR
    --Window Edge Coordinates
    --how far away a poitn is from a line
    -- +ive to left of line. -ive to right of line
    WEC1, WEC2 : ARRAY[2] OF REAL
  BEGIN
    --create vector normals, and perpendicular normals
    --for both lines
    n_l1 = (l1.r1 - l1.r0)/math__norm((l1.r1 - l1.r0))
    perp_l1 = draw__perpendicular_vector(n_l1)

    n_l2 = (l2.r1 - l2.r0)/math__norm((l2.r1 - l2.r0))
    perp_l2 = draw__perpendicular_vector(n_l2)

    --for each endpoint determine which side of the opposing line
    --it is on. Using a lines (Q1Q2) perpendicular vector (Q2-Q1)⊥, 
    --and the dot product between a point's (P) vector with the line (PQ1).
    --The product will be negative to the right of the line (In the negative
    --half space of the line), or positive to the left of the line (In the 
    --positive half space of the line).
    -- (ref: https://math.stackexchange.com/questions/2945417/unknown-mathematical-symbols)

    --using l2 line (P-Q1)*(Q2-Q1)⊥
    WEC1[1] = (l1.r0 - l2.r0)@perp_l2
    WEC1[2] = (l1.r1 - l2.r0)@perp_l2

    --using l1 line (P-Q1)*(Q2-Q1)⊥
    WEC2[1] = (l2.r0 - l1.r0)@perp_l1
    WEC2[2] = (l2.r1 - l1.r0)@perp_l1

    --if endpoints are on opposite sides of the line (one +ive, one -ive), 
    --the line intersects with the other one.
    --..note:: WEC1[1]*WEC1[2] > 0.0001 addresses real rounding issue with
    --          epsilon values breaking comparative.
    IF (WEC1[1]*WEC1[2] > 0.0001) OR (WEC2[1]*WEC2[2] > 0.0001) THEN
      RETURN(FALSE)
    ELSE
      --ratios with WEC can be made to give a ratio for how for much of one
      --line lies to the left of another line. For clipping the line you
      --would want to remove the 1-alpha of the line if your polygon hull is
      --sequenced ccw.
      out_alpha1 = WEC1[1]/(WEC1[1]-WEC1[2])
      out_alpha2 = WEC2[1]/(WEC2[1]-WEC2[2])

      RETURN(TRUE)
    ENDIF

    RETURN(FALSE)
  END draw__intersect


-- private polygon routines

--comparator = TRUE : >, comparator = FALSE : <
ROUTINE glt(r1, r2 : REAL; comparator : BOOLEAN) : BOOLEAN
  BEGIN
    IF comparator THEN
      RETURN(r1 > r2)
    ELSE
      RETURN(r1 < r2)
    ENDIF
  END glt


ROUTINE minmax(point_arr : PATH nodedata = t_VERTEX; search_vec : VECTOR; comparator : BOOLEAN) : INTEGER
  VAR
   i : INTEGER
   minmax_idx : INTEGER
   valy, valx : REAL
   origin : VECTOR
   perp_vec : VECTOR
  BEGIN
    origin = VEC2D(0,0)
    --get perpendicular vector
    perp_vec = draw__perpendicular_vector(search_vec)
    --find y min
    minmax_idx = 1
    --dot product between (point-origin) and search vector
    --will give the point with the maximum distance from the
    --origin wrt the search vector
    valy = (search_vec@(point_arr[1].coords-origin))
    FOR i=2 TO PATH_LEN(point_arr) DO

      IF (glt( (search_vec@(point_arr[i].coords-origin)), valy, comparator) ) THEN
        valy = (search_vec@(point_arr[i].coords-origin)) 
        minmax_idx = i

      ELSE IF ((search_vec@(point_arr[i].coords-origin)) = valy) THEN
        valx = (perp_vec@(point_arr[minmax_idx].coords-origin))
        IF (glt( (perp_vec@(point_arr[i].coords-origin)), valx,  NOT comparator) ) THEN
          valx = (perp_vec@(point_arr[minmax_idx].coords-origin))
          minmax_idx = i
        ENDIF
      ENDIF
      ENDIF
    ENDFOR

    RETURN(minmax_idx)

  END minmax

ROUTINE draw__find_min
  BEGIN
    RETURN( minmax(point_arr, search_vec, FALSE) )
  END draw__find_min

ROUTINE draw__find_max
  BEGIN
    RETURN( minmax(point_arr, search_vec, TRUE) )
  END draw__find_max

ROUTINE draw__on_hull
  VAR
    i : INTEGER
    b : BOOLEAN
  BEGIN
    b = FALSE
    FOR i=1 TO PATH_LEN(hull) DO
      IF (v = hull[i].coords) THEN
        b = TRUE
      ENDIF
    ENDFOR

    RETURN(b)
  END draw__on_hull

ROUTINE draw__point_collision_convex
  VAR
    i : INTEGER
    b : BOOLEAN
    cross : VECTOR
    sp, ep : INTEGER
  BEGIN
    --If looping from end of path to start of path
    IF end_node < start_node THEN
      end_node = end_node + PATH_LEN(polygon)
    ENDIF

    FOR i = (start_node+1) TO end_node DO
      --loop around path back to start
      sp = ((i-1-1) MOD PATH_LEN(polygon)) + 1
      ep = ((i-1) MOD PATH_LEN(polygon)) + 1
      cross = (polygon[ep].coords - polygon[sp].coords)#(v-polygon[sp].coords)
      --if determinate is negative it is to the right of the line
      --and is outside a convex polygon
      IF cross.z < 0 THEN
        RETURN(FALSE)
      ENDIF
    ENDFOR

    RETURN(TRUE)
  END draw__point_collision_convex

ROUTINE draw__point_avoid_convex
  VAR
    i : INTEGER
    b : BOOLEAN
    cross : VECTOR
    sp, ep : INTEGER
  BEGIN
    --If looping from end of path to start of path
    IF end_node < start_node THEN
      end_node = end_node + PATH_LEN(polygon)
    ENDIF

    FOR i = (start_node+1) TO end_node DO
      --loop around path back to start
      sp = ((i-1-1) MOD PATH_LEN(polygon)) + 1
      ep = ((i-1) MOD PATH_LEN(polygon)) + 1
      cross = (polygon[ep].coords - polygon[sp].coords)#(v-polygon[sp].coords)
      --if determinate is negative it is to the right of the line
      --and is outside a convex polygon
      IF cross.z > 0 THEN
        RETURN(FALSE)
      ENDIF
    ENDFOR

    RETURN(TRUE)
  END draw__point_avoid_convex

ROUTINE draw__point_collision_polygon
  VAR
    i, j : INTEGER
    b : BOOLEAN
    reflex_verts : ARRAY[30] OF INTEGER
    reflex_start, reflex_end : INTEGER
  BEGIN
    --assume polygon verticies are ordered counterclockwise
    --If point is to the left of all lines on the polygon
    --point might be in the polygon
    b = draw__point_collision_convex(v, polygon, 1, PATH_LEN(polygon))
    --if point is to the left of all lines it is in the polygon
    IF b = TRUE THEN RETURN(TRUE) ; ENDIF

    --check the convex hull to see if it is outside of the hull
    b = draw__point_collision_convex(v, hull, 1, PATH_LEN(hull))
    --if point is to the right of any lines on the hull it is
    --outside of the polygon
    IF NOT b THEN RETURN(FALSE) ; ENDIF

    --check for reflexive verticies
    j = 0
    FOR i = 1 TO PATH_LEN(polygon) DO
      IF NOT draw__on_hull(polygon[i].coords, hull) THEN
        j = j + 1
        reflex_verts[j] = i
      ENDIF
    ENDFOR

    --if any, test if point is
    --inside these areas
    IF j > 0 THEN
      --endflag
      j = j + 1
      reflex_verts[j] = 2147483646
      --start and end polygons are points on the hull
      --before and after the reflexive points
      --mod operator does not handle negatives
      IF reflex_verts[1] = 1 THEN
        reflex_start = PATH_LEN(polygon)
      ELSE
        reflex_start = ((reflex_verts[1]-1-1) MOD PATH_LEN(polygon)) + 1
      ENDIF

      FOR i=1 TO j-1 DO
        --if next vertex is not reflexive, we have reached the hull
        IF (reflex_verts[i] <> reflex_verts[i+1]-1) THEN
          reflex_end = ((reflex_verts[i]+1-1) MOD PATH_LEN(polygon)) + 1
          
          --test poly
          b = draw__point_avoid_convex(v, polygon, reflex_start, reflex_end)
          -- if found inside these interior regions it is not in the polygon
          IF b THEN RETURN(FALSE); ENDIF

          reflex_start = ((reflex_verts[i+1]-1-1) MOD PATH_LEN(polygon)) + 1
        ENDIF
      ENDFOR
    ENDIF

    RETURN(TRUE)

  END draw__point_collision_polygon


-- public polygon routines
ROUTINE draw__convex_hull
-- (ref : https://www.geeksforgeeks.org/convex-hull-set-1-jarviss-algorithm-or-wrapping/)
-- (ref : https://www.topcoder.com/community/competitive-programming/tutorials/geometry-concepts-line-intersection-and-its-applications#convexhull)
  VAR
   i : INTEGER
   min_hull : INTEGER
   curr, nxt, tst : INTEGER
   cross : VECTOR
   dot : REAL
   det : REAL
   status : INTEGER
  BEGIN
    --clear hull
    i = PATH_LEN(out_hull)
    WHILE PATH_LEN(out_hull) > 0 DO
		  DELETE_NODE(out_hull,i,status)
      i = i - 1
	  ENDWHILE

    --find y min
    min_hull = draw__find_min(verticies, VEC2D(0,1))
    --min point must be on hull
    curr = min_hull

    --skip first point as we know it is min_hull
    -- and will be the last found hull point

    REPEAT
      -- reset tentative hull point
      nxt = -1

      FOR i=1 TO PATH_LEN(verticies) DO
        -- continuous loop from 1..path_len
        tst = ((curr+i-1) MOD PATH_LEN(verticies)) + 1
        -- cross product will determine the furthest point
        -- from the line nxt->curr.

        --Do not test if in hull set. But abort out 
        IF (tst <> curr) AND NOT draw__on_hull(verticies[tst].coords, out_hull) THEN
          IF (nxt = -1) THEN
            nxt = ((curr+i-1) MOD PATH_LEN(verticies)) + 1
          ENDIF

          cross = (verticies[curr].coords-verticies[nxt].coords)#(verticies[tst].coords-verticies[nxt].coords)
          det = cross.z

          --det = 0, nxt and tst are colinear
          IF rmv_colinear THEN
            IF (det = 0) THEN
              --points are on the same line select the one furthest
              --away
              dot = (verticies[curr].coords-verticies[nxt].coords)@(verticies[tst].coords-verticies[nxt].coords)
              -- if dot product is negative tst is further away
              IF (dot < 0) THEN
                nxt = tst
              ENDIF
            ENDIF
          ENDIF

          IF det > 0 THEN
            nxt = tst
          ENDIF
        ENDIF
      ENDFOR
      -- add point furthest counter clockwise from current point to hull
      curr = nxt

      APPEND_NODE(out_hull,status)
      out_hull[PATH_LEN(out_hull)].coords = verticies[nxt].coords

    UNTIL(curr = min_hull)

    --add min_hull to the start of the list
    INSERT_NODE(out_hull,1,status)
    CHK_STAT(status)
    out_hull[1].coords =  verticies[nxt].coords

  END draw__convex_hull


ROUTINE draw__bounding_box
  VAR
    edges : ARRAY[4] OF VECTOR
    box : t_RECT
    align_vec, perp_vec : VECTOR
    frm : XYZWPR
    i : INTEGER
  BEGIN
    --y-axis vector
    align_vec = draw__angle_to_vector(angle + 90)
    --x-axis vector
    perp_vec = draw__perpendicular_vector(align_vec)

    --find four corners
    edges[1] = verticies[draw__find_min(verticies, align_vec)].coords
    edges[2] = verticies[draw__find_max(verticies, perp_vec)].coords
    edges[3] = verticies[draw__find_max(verticies, align_vec)].coords
    edges[4] = verticies[draw__find_min(verticies, perp_vec)].coords

    --put edges in rotated frame
    frm.x = 0; frm.y = 0; frm.z = 0; frm.w = 0; frm.p = 0; frm.r = angle ;
    FOR i=1 TO ARRAY_LEN(edges) DO
      edges[i] = INV((frm)):edges[i]
    ENDFOR

    box.verts[1] = frm:(VEC2D(edges[2].x, edges[1].y))
    box.verts[2] = frm:(VEC2D(edges[4].x, edges[1].y))
    box.verts[3] = frm:(VEC2D(edges[4].x, edges[3].y))
    box.verts[4] = frm:(VEC2D(edges[2].x, edges[3].y))

    box.vec[1] = align_vec
    box.vec[2] = perp_vec
    box.center = math__average_vector(box.verts)

    RETURN(box)

  END draw__bounding_box


ROUTINE draw__clip_lines
  VAR
    line1_alpha, line2_alpha : REAL
    intersect : BOOLEAN
  BEGIN
    intersect = draw__intersect(line1, line2, line1_alpha, line2_alpha)
    IF intersect THEN
      --clip lines
      line1.r1 = (1-line1_alpha)*line1.r0 + line1_alpha*line1.r1
      line2.r0 = (1-line2_alpha)*line2.r0 + line2_alpha*line2.r1
    ENDIF

  END draw__clip_lines


ROUTINE draw__clip_line_with_poly
  VAR
--assumed maximum number of times a polygon will
--intersect a single line
%define total_clips 20
    clippedverts : ARRAY[total_clips] OF t_VERT_CLIP
    i,j : INTEGER
    next_vert : t_VERTEX
    poly_seg : t_SEGMENT2D
    line_alpha, poly_alpha : REAL
    intersect : BOOLEAN
    entryexit, collision :  BOOLEAN
    status : INTEGER
  BEGIN
    --clipped vertex index
    j = 0
    --is the start point of line inside or outside polygon
    --assume polygon verticies are ordered counterclockwise
    collision = draw__point_collision_polygon(line.r0, polygon, hull)

    --If inside the polygon add to vertex list
    IF collision THEN
      j = j + 1
      clippedverts[j].coords = line.r0
      clippedverts[j].alpha = 0
      clippedverts[j].intersect = FALSE
      entryexit = TRUE
      clippedverts[j].entry_exit = entryexit
    ELSE
      entryexit = FALSE
    ENDIF

    FOR i=1 TO PATH_LEN(polygon) DO
      --increment loop
      next_vert = polygon[((i+1-1) MOD PATH_LEN(polygon)) + 1]
      IF (polygon[i].polygon = next_vert.polygon) THEN 
        poly_seg.r0 = polygon[i].coords
        poly_seg.r1 = next_vert.coords
        --find intersection
        --intersection is read from left of the subject line to the right
        intersect = draw__intersect(line, poly_seg, line_alpha, poly_alpha)
        IF intersect THEN
          j = j + 1
          --coordinates of intersection point
          clippedverts[j].coords = (1-line_alpha)*line.r0 + line_alpha*line.r1
          clippedverts[j].alpha = line_alpha
          clippedverts[j].intersect = intersect
          clippedverts[j].polygon = polygon[i].polygon
        ENDIF
      ENDIF
    ENDFOR

    --if any intersection are found
    IF j > 0 THEN
      --sort points by alpha value
      srtclp__quicksort(clippedverts, 1, j, FALSE)

      --label verticies as entry (TRUE) or exit (FALSE) nodes
      --first node will be an entry node
      entryexit = TRUE
      clippedverts[1].entry_exit = entryexit

      FOR i=2 TO j DO
        entryexit = NOT entryexit
        clippedverts[j].entry_exit = entryexit
        
        --add new clipped line segment on exit node
        IF NOT entryexit THEN
          APPEND_NODE(out_lines, status)
          out_lines[PATH_LEN(out_lines)].r0 = clippedverts[i-1].coords
          out_lines[PATH_LEN(out_lines)].r1 = clippedverts[i].coords
        ENDIF
      ENDFOR

      --if there is an entry node with no corresponding exit node
      IF entryexit THEN
        --check if enpoint of the line is inside the polygon
        collision = draw__point_collision_polygon(line.r0, polygon, hull)
        IF collision THEN
          APPEND_NODE(out_lines, status)
          out_lines[PATH_LEN(out_lines)].r0 = clippedverts[j].coords
          out_lines[PATH_LEN(out_lines)].r1 = line.r1
        ENDIF
      ENDIF

    ENDIF
  END draw__clip_line_with_poly

ROUTINE draw__raster_lines
  VAR
    i : INTEGER
    bbox : t_RECT
    new_line : t_SEGMENT2D
    startpoint,endpoint : VECTOR
    no_of_lines : INTEGER
    status : INTEGER
  BEGIN
    --draw convex hull around polygon
    draw__convex_hull(polygon, FALSE, out_hull)
    --define a bounding box around polygon and fill with line segments
    bbox = draw__bounding_box(polygon, raster_angle)
    --define how many lines will be made based on height of box
    --and line pitch
    -- no_of_lines = ceil((box_height-line_width)/pitch)
    --inc = math__ceil((math__norm(bbox.verts[4]-bbox.verts[1])-line_width)/line_pitch)

    --all boundaries are assumed to be ordered counterclockwise
    startpoint = bbox.vec[1]*(line_width/2) + bbox.verts[1]
    endpoint = bbox.vec[1]*(line_width/2) + bbox.verts[2]

    --repeat until clipping stops producing lines
    i = 0
    REPEAT
      no_of_lines = PATH_LEN(out_lines)
      new_line.r0 = bbox.vec[1]*line_pitch*(i) + startpoint
      new_line.r1 = bbox.vec[1]*line_pitch*(i) + endpoint
      --clip lines to polygon
      draw__clip_line_with_poly(new_line, polygon, out_hull, out_lines)

      i = i + 1
    UNTIL(PATH_LEN(out_lines) = no_of_lines)

    --return out_lines

  END draw__raster_lines

ROUTINE draw__line_inset
  VAR
    line1_alpha, line2_alpha : REAL
    line_vec1, line_vec2 : VECTOR
    perp_vec1,perp_vec2 : VECTOR
    intersect : BOOLEAN
  BEGIN
    --get line vector
    line_vec1 = (line1.r1-line1.r0)/math__norm(line1.r1-line1.r0)
    --inset lines based on perpendicular vector
    out_line1.r0 = draw__perpendicular_vector(line_vec1)*inset_amount + line1.r0
    out_line1.r1 = draw__perpendicular_vector(line_vec1)*inset_amount + line1.r1

    --get line vector
    line_vec2 = (line2.r1-line2.r0)/math__norm(line2.r1-line2.r0)
    --inset lines based on perpendicular vector
    out_line2.r0 = draw__perpendicular_vector(line_vec2)*inset_amount + line2.r0
    out_line2.r1 = draw__perpendicular_vector(line_vec2)*inset_amount + line2.r1

    --clip line with previous line
    intersect = draw__intersect(out_line1, out_line2, line1_alpha, line2_alpha)
    IF intersect THEN
      out_line1.r1 = (1-line1_alpha)*out_line1.r0 + line1_alpha*out_line1.r1
      out_line2.r0 = (1-line2_alpha)*out_line2.r0 + line2_alpha*out_line2.r1
    ELSE
      --concave lines may not intersect. Increase r1 of the previous line,
      --and r0 of the current line to see if they clip.
      out_line1.r1 = line_vec1*inset_amount + out_line1.r1
      out_line2.r0 =  out_line2.r0 - line_vec2*inset_amount
      intersect = draw__intersect(out_line1, out_line2, line1_alpha, line2_alpha)
      IF intersect THEN
        out_line1.r1 = (1-line1_alpha)*out_line1.r0 + line1_alpha*out_line1.r1
        out_line2.r0 = (1-line2_alpha)*out_line2.r0 + line2_alpha*out_line2.r1
      ENDIF
    ENDIF
  END draw__line_inset

ROUTINE draw__inset_polygon
  VAR
    i, j : INTEGER
    poly_count, first_vert : INTEGER
    next_vert, curr_vert : t_VERTEX
    new_line, prev_line : t_SEGMENT2D
    new_inset, prev_inset : t_SEGMENT2D
    uninit_line : t_SEGMENT2D
    status : INTEGER
  BEGIN
    --check output polygon for verticies
    --get polygon count
    IF PATH_LEN(out_polygon) > 0 THEN
      IF out_polygon[PATH_LEN(out_polygon)].polygon < 255 THEN
        poly_count = out_polygon[PATH_LEN(out_polygon)].polygon + 1
      ENDIF
    ENDIF

    IF UNINIT(poly_count) OR (poly_count = 0) THEN
      poly_count = 1
    ENDIF

    first_vert = 1
    FOR i=1 TO PATH_LEN(polygon) + 1 DO
      --curent vert = i
      curr_vert = polygon[((i-1) MOD PATH_LEN(polygon)) + 1]
      --next vert = i+1
      next_vert = polygon[((i+1-1) MOD PATH_LEN(polygon)) + 1]

      --next line
      new_line.r0 = curr_vert.coords ; new_line.r1 = next_vert.coords ;
      
      IF NOT UNINIT(prev_line.r0) THEN

        IF (curr_vert.polygon <> next_vert.polygon) OR (i = PATH_LEN(polygon)) THEN
          --evaluate line between first and last index of polygon
          next_vert = polygon[first_vert]

          --next line
          new_line.r0 = curr_vert.coords ; new_line.r1 = next_vert.coords ;

          --find intersection of inset lines
          draw__line_inset(prev_line, new_line, inset_amount, prev_inset, new_inset)

          --add intersection point to new polygon
          APPEND_NODE(out_polygon, status)
          out_polygon[PATH_LEN(out_polygon)].coords = new_inset.r0
          out_polygon[PATH_LEN(out_polygon)].polygon = poly_count

          prev_line = new_line

          --close polygon, on the first vertex
          curr_vert = polygon[first_vert]
          next_vert = polygon[first_vert+1]

          --next line
          new_line.r0 = curr_vert.coords ; new_line.r1 = next_vert.coords ;

          --find intersection of inset lines
          draw__line_inset(prev_line, new_line, inset_amount, prev_inset, new_inset)

          --add intersection point to new polygon
          APPEND_NODE(out_polygon, status)
          out_polygon[PATH_LEN(out_polygon)].coords = new_inset.r0
          out_polygon[PATH_LEN(out_polygon)].polygon = poly_count

          --uninitialize prev_line
          prev_line = uninit_line

          --fill 'nextpoly' member for all verticies in new polygon
          IF i+1 < PATH_LEN(polygon) THEN
            FOR j=i DOWNTO first_vert DO
              out_polygon[j].nextpoly = i+1
            ENDFOR
          ENDIF

          --update pointer for first vertex of the next polygon
          first_vert = ((i+1-1) MOD PATH_LEN(polygon)) + 1

          poly_count = poly_count + 1
        ELSE
          --find intersection of inset lines
          draw__line_inset(prev_line, new_line, inset_amount, prev_inset, new_inset)

          --add intersection point to new polygon
          APPEND_NODE(out_polygon, status)
          out_polygon[PATH_LEN(out_polygon)].coords = new_inset.r0
          out_polygon[PATH_LEN(out_polygon)].polygon = poly_count

          prev_line = new_line

        ENDIF
      ELSE
        prev_line = new_line
      ENDIF
    ENDFOR
  END draw__inset_polygon

BEGIN
END draw

