PROGRAM draw
%NOBUSYLAMP
%COMMENT = '2d library'
%NOLOCKGROUP
%NOPAUSE = COMMAND + TPENABLE + ERROR

%include systemvars.klt
%include math.klt
%include draw.klt

%include systemlib.klh
%from math.klh %import norm, norm2
%include draw.klh

ROUTINE VEC2D
  VAR
    v : VECTOR
  BEGIN
    v.x = x; v.y = y; v.z = 0;
    RETURN(v)
  END VEC2D

ROUTINE draw__vec_to_vec2d
  VAR
    v_trans : VECTOR
    v2 : VECTOR
  BEGIN
    --get vector relative to frame
    v_trans = INV((frame)):v
    --remove z componenet
    v2.x = v_trans.x ; v2.y = v_trans.y ; v2.z = 0 ;
    RETURN(v2)
  END draw__vec_to_vec2d
  
ROUTINE draw__vec2d_to_vec
  VAR
    v2 : VECTOR
  BEGIN
    v2.x = v.x ; v2.y = v.y ; v2.z = 0 ;
    v2 = frame:v2
    RETURN(v2)
  END draw__vec2d_to_vec

ROUTINE draw__vec2d_to_pos
  VAR
    v2 : VECTOR
    p : XYZWPR
  BEGIN
    v2.x = v.x ; v2.y = v.y ; v2.z = 0 ;
    v2 = frame:v2
    --add orientation
    p.w = frame.w; p.p = frame.p; p.r = frame.r;

    RETURN(p)
  END draw__vec2d_to_pos

ROUTINE draw__LINE_to_LINE2D
  VAR
    l2 : t_LINE2D
  BEGIN
    l2.point = draw__vec_to_vec2d(l.point, frame)
    l2.vec = draw__vec_to_vec2d(l.vec, frame)

    RETURN(l2)
  END draw__LINE_to_LINE2D

ROUTINE draw__LINE2D_to_LINE
  VAR
    l2 : t_LINE
  BEGIN
    l2.point = draw__vec2d_to_vec(l.point, frame)
    l2.vec = draw__vec2d_to_vec(l.vec, frame)

    RETURN(l2)
  END draw__LINE2D_to_LINE

ROUTINE draw__SEGMENT_to_SEGMENT2D
  VAR
    l2 : t_SEGMENT2D
  BEGIN
    l2.r0 = draw__vec_to_vec2d(l.r0, frame)
    l2.r1 = draw__vec_to_vec2d(l.r1, frame)

    RETURN(l2)
  END draw__SEGMENT_to_SEGMENT2D

ROUTINE draw__SEGMENT2D_to_SEGMENT
  VAR
    l2 : t_SEGMENT
  BEGIN
    l2.r0 = draw__vec2d_to_vec(l.r0, frame)
    l2.r1 = draw__vec2d_to_vec(l.r1, frame)

    RETURN(l2)
  END draw__SEGMENT2D_to_SEGMENT


ROUTINE draw__perpendicular_vector
  VAR
    v_out : VECTOR
  BEGIN
    v_out.x = -1*v.y
    v_out.y = v.x
    v_out.z = 0
    RETURN(v_out)
  END draw__perpendicular_vector

ROUTINE draw__angle_to_vector
  VAR
    v : VECTOR
  BEGIN
    v.x = COS(angle) ; v.y = SIN(angle) ; v.z = 0;
    RETURN(v)
  END draw__angle_to_vector

ROUTINE draw__vector_to_angle
  BEGIN
    RETURN(ATAN2(v.y, v.x) * 180/M_PI)
  END draw__vector_to_angle

ROUTINE draw__intersect
  VAR
    --line normals
    n_l1, n_l2 : VECTOR
    -- perpendicular line normals
    perp_l1, perp_l2 : VECTOR
    --Window Edge Coordinates
    --how far away a poitn is from a line
    -- +ive to left of line. -ive to right of line
    WEC1, WEC2 : ARRAY[2] OF REAL
  BEGIN
    --create vector normals, and perpendicular normals
    --for both lines
    n_l1 = (l1.r1 - l1.r0)/math__norm((l1.r1 - l1.r0))
    perp_l1 = draw__perpendicular_vector(n_l1)

    n_l2 = (l2.r1 - l2.r0)/math__norm((l2.r1 - l2.r0))
    perp_l2 = draw__perpendicular_vector(n_l2)

    --for each endpoint determine which side of the opposing line
    --it is on. Using a lines (Q1Q2) perpendicular vector (Q2-Q1)⊥, 
    --and the dot product between a point's (P) vector with the line (PQ1).
    --The product will be negative to the right of the line (In the negative
    --half space of the line), or positive to the left of the line (In the 
    --positive half space of the line).
    -- (ref: https://math.stackexchange.com/questions/2945417/unknown-mathematical-symbols)

    --using l2 line (P-Q1)*(Q2-Q1)⊥
    WEC1[1] = (l1.r0 - l2.r0)@perp_l2
    WEC1[2] = (l1.r1 - l2.r0)@perp_l2

    --using l1 line (P-Q1)*(Q2-Q1)⊥
    WEC2[1] = (l2.r0 - l1.r0)@perp_l1
    WEC2[2] = (l2.r1 - l1.r0)@perp_l1

    --if endpoints are on opposite sides of the line (one +ive, one -ive), 
    --the line intersects with the other one.
    IF (WEC1[1]*WEC1[2] > 0) AND (WEC2[1]*WEC2[2] > 0) THEN
      RETURN(FALSE)
    ELSE
      --ratios with WEC can be made to give a ratio for how for much of one
      --line lies to the left of another line. For clipping the line you
      --would want to remove the 1-alpha of the line if your polygon hull is
      --sequenced ccw.
      out_alpha1 = WEC1[1]/(WEC1[1]-WEC1[2])
      out_alpha2 = WEC2[1]/(WEC2[1]-WEC2[2])

      RETURN(TRUE)
    ENDIF

    RETURN(FALSE)
  END draw__intersect

BEGIN
END draw

